<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loop&#39;s Blog</title>
  <icon>https://blog.notgame.top/icon.png</icon>
  
  <link href="https://blog.notgame.top/atom.xml" rel="self"/>
  
  <link href="https://blog.notgame.top/"/>
  <updated>2022-03-13T11:17:18.725Z</updated>
  <id>https://blog.notgame.top/</id>
  
  <author>
    <name>Loop</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈</title>
    <link href="https://blog.notgame.top/2021/09/05/%E6%A0%88/"/>
    <id>https://blog.notgame.top/2021/09/05/%E6%A0%88/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2022-03-13T11:17:18.725Z</updated>
    
    
    <summary type="html">什么是栈？
栈和顺序表、链表一样，也是存储逻辑关系为“一对一”的数据。
和顺序表、链表不一样的是，栈的存和取有限制：

 * 一端封闭，一端开口，只能从开口处存取数据
 * 存取遵循“先进后出”的原则，即最先进栈的元素最后出栈

因此，栈是只能从一端存取数据的先进后出的数据结构。
开口的一端叫栈顶，封闭的一端叫栈底。向栈中添加数据叫进栈，从栈中取数据叫出栈。

栈的实现
栈主要有两种实现方式：

 * 顺序栈：采用顺序存储结构
 * 链栈：采用链式存储结构

通用接口
因为栈有不同的实现，所以定义一个接口，可以根据接口实现不同的栈

1
2
3
4
5
6
7
8
9
10
11
12
13
</summary>
    
    
    
    
    <category term="数据结构" scheme="https://blog.notgame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://blog.notgame.top/2021/08/27/%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.notgame.top/2021/08/27/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2022-03-13T11:15:57.110Z</updated>
    
    
    <summary type="html">什么是链表？
链表又叫单链表，是链式存储结构的线性表。在内存中是散乱随机存储的。
链表中的数据由结点表示，由两部分组成：

 * 数据本身，所在区域称为数据域
 * 指向直接后继元素的指针（C#中为引用），所在区域称为指针域

头指针、头结点、首元结点是什么？
一个链表光有结点还不完整。
一个完整的链表由以下几部分构成：

 * 头指针：永远指向链表第一个位置。用于指明链表的位置，便于找到链表并使用链表中的数据。
 * 结点： * 头结点：没有数据的空结点，作为链表的第一个结点。不是必须有。
    * 首元结点：链表中第一个存有数据的结点。
    * 其他结点：链表中除以上结点以外的其他的</summary>
    
    
    
    
    <category term="数据结构" scheme="https://blog.notgame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺序表</title>
    <link href="https://blog.notgame.top/2021/08/18/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <id>https://blog.notgame.top/2021/08/18/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</id>
    <published>2021-08-17T16:00:00.000Z</published>
    <updated>2022-03-13T11:16:59.584Z</updated>
    
    
    <summary type="html">什么是顺序表？
线性表是逻辑关系为1对1的数据结构。数据结构分为顺序存储结构和链式存储结构。
顺序表就是顺序存储结构的线性表。
顺序表又分为静态顺序表和动态顺序表：

 * 静态顺序表：列表最大长度固定，不会在运行时改变。
 * 动态顺序表：运行时可以根据数据的多少，动态改变列表的最大长度。

静态顺序表的实现
通过数组实现。具体数据结构为:
数组和表的长度

1
2
3
4
5


public StaticSeqList
{
    private int[] list;
    private int count;
}


可以定义一些方便使用的属性和方法

1
2
3
4
5
6
7
</summary>
    
    
    
    
    <category term="数据结构" scheme="https://blog.notgame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://blog.notgame.top/2021/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.notgame.top/2021/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2022-03-13T11:16:40.861Z</updated>
    
    
    <summary type="html">什么是数据结构？
我们知道数据是存储在计算机的物理存储空间中的，这些空间不是无限的，是宝贵的。我们需要选择一种好的存储方式来存储数据。并且在需要进行大量数据处理的时候，处理的时间也是宝贵的，高效方便的数据再利用很重要。所以，我们需要研究数据结构。 

那么，什么是数据结构？简单的来讲就是研究数据的存储方式。复杂点来讲，数据结构是一门学科，研究如何存储具有复杂关系的数据，并且有助于数据的再利用。 

如何选择数据结构？
数据结构分为线性表、树、图三种存储结构，这三种存储结构又可细分为顺序和链式两种物理结构。
那么，该如何选取这些存储结构？主要取决于两方面：数据的逻辑关系和物理存储结构。
首先是确</summary>
    
    
    
    
    <category term="数据结构" scheme="https://blog.notgame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <link href="https://blog.notgame.top/2021/08/12/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://blog.notgame.top/2021/08/12/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2021-08-11T16:00:00.000Z</published>
    <updated>2022-03-13T11:13:00.387Z</updated>
    
    
    <summary type="html">如何评价一个算法的好坏？
算法是什么？
算法是解决问题的方法。 

解决一个问题的方法很多，但是不一定都是最高效的，但我们也不可能把所有的方法都实现一遍，然后一一比对。因此，我们需要一些评判标准去衡量这些方法的好坏。

那么，如何去判断一个算法的好坏呢？
首先，它必须能彻底解决问题。
其次，程序在任何情况下都不会崩溃。
在此基础上，程序运行时间更短，占用内存更少，就认为这个算法更好。

用专业一点的话总结，就是如下几点：

 * 准确性：彻底解决问题
 * 健壮性：不崩溃
 * 时间复杂度：时间效率
 * 空间复杂度：占用空间

时间复杂度
判断一个算法的运行时间，不会真的把它编写出来，然后运</summary>
    
    
    
    
    <category term="数据结构" scheme="https://blog.notgame.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://blog.notgame.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Aseprite画像素UI的一些建议</title>
    <link href="https://blog.notgame.top/2021/08/10/Aseprite%E7%94%BB%E5%83%8F%E7%B4%A0UI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>https://blog.notgame.top/2021/08/10/Aseprite%E7%94%BB%E5%83%8F%E7%B4%A0UI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2022-03-13T11:19:00.451Z</updated>
    
    
    <summary type="html">* 使用一个大画布，把所有UI元素和图标都画在上面。 * 打开背景网格作为尺寸参考，这样能够方便把握Sprite的大小，以及后续导入Unity后的Sprite切割（aseprite不支持单独切割Sprite并导出，只能整个画布一起导出）。
    * 从整体上把握UI风格，保持一致。例如：圆角还是尖角？阴影还是平面？ 3D 还是 2D？透视角度？
   
   
 * 事先决定好需要的UI元素和图标，用清单把它们列出来。 * 查看UI元素的网站：usability.gov。
   
   
 * 使用垂直剖面线风格的阴影，不要使用抖动阴影（看起来会很脏）。
 * 在Sprite下方使用较暗、冷</summary>
    
    
    
    
    <category term="像素画" scheme="https://blog.notgame.top/tags/%E5%83%8F%E7%B4%A0%E7%94%BB/"/>
    
  </entry>
  
</feed>
