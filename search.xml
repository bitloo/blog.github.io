<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Aseprite画像素UI的一些建议</title>
    <url>/2021/08/10/Aseprite%E7%94%BB%E5%83%8F%E7%B4%A0UI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<ul>
<li>使用一个大画布，把所有UI元素和图标都画在上面。<ul>
<li>打开背景网格作为尺寸参考，这样能够方便把握Sprite的大小，以及后续导入Unity后的Sprite切割（aseprite不支持单独切割Sprite并导出，只能整个画布一起导出）。</li>
<li>从整体上把握UI风格，保持一致。例如：圆角还是尖角？阴影还是平面？ 3D 还是 2D？透视角度？</li>
</ul>
</li>
<li>事先决定好需要的UI元素和图标，用清单把它们列出来。<ul>
<li>查看UI元素的网站：usability.gov。</li>
</ul>
</li>
<li>使用垂直剖面线风格的阴影，不要使用抖动阴影（看起来会很脏）。</li>
<li>在Sprite下方使用较暗、冷色调的像素线来达到3D效果。</li>
<li>使用描边和阴影让UI和屏幕中的其他元素区分开来。<ul>
<li>描边和阴影不要使用纯黑或者灰色，应该根据Sprite的颜色而决定。</li>
</ul>
</li>
<li>使用非像素UI作为参考，并把它们抽象出来形成像素画。<ul>
<li>参考图标的网站：flaticon.com。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>美术</category>
      </categories>
      <tags>
        <tag>像素画</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2021/08/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>我们知道数据是存储在计算机的物理存储空间中的，这些空间不是无限的，是宝贵的。我们需要选择一种好的存储方式来存储数据。并且在需要进行大量数据处理的时候，处理的时间也是宝贵的，高效方便的数据再利用很重要。所以，我们需要研究数据结构。  </p>
<p>那么，什么是数据结构？简单的来讲就是研究数据的存储方式。复杂点来讲，数据结构是一门学科，研究如何存储具有复杂关系的数据，并且有助于数据的再利用。 </p>
<h2 id="如何选择数据结构？"><a href="#如何选择数据结构？" class="headerlink" title="如何选择数据结构？"></a>如何选择数据结构？</h2><p>数据结构分为线性表、树、图三种存储结构，这三种存储结构又可细分为顺序和链式两种物理结构。<br>那么，该如何选取这些存储结构？主要取决于两方面：数据的逻辑关系和物理存储结构。<br>首先是确定逻辑关系。<br>逻辑关系就是数据之间的对应关系，分为三类：</p>
<ul>
<li>一对一关系：左右两侧都只有一个邻居，选择线性表</li>
<li>一对多关系：只有一个父亲，但是有多个孩子，选择树</li>
<li>多对多关系：每条路互相连接，都可以到达，选择图</li>
</ul>
<p>确定好逻辑关系后，再确定物理存储结构。<br>物理存储结构就是数据在物理存储空间上选择集中存储还是分散存储，分为两类：</p>
<ul>
<li>顺序：集中存储，有利于对数据做遍历操作</li>
<li>链式：分散存储，有利于对数据做增删操作</li>
</ul>
<p>有大量数据需要遍历查询的，就选择顺序存储结构；需要频繁增加和删除数据的，就选择链式存储结构。<br>通过上面两个点，很容易确定一个数据结构。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <url>/2021/08/12/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="如何评价一个算法的好坏？"><a href="#如何评价一个算法的好坏？" class="headerlink" title="如何评价一个算法的好坏？"></a>如何评价一个算法的好坏？</h2><p>算法是什么？<br>算法是解决问题的方法。  </p>
<p>解决一个问题的方法很多，但是不一定都是最高效的，但我们也不可能把所有的方法都实现一遍，然后一一比对。因此，我们需要一些评判标准去衡量这些方法的好坏。</p>
<p>那么，如何去判断一个算法的好坏呢？<br>首先，它必须能彻底解决问题。<br>其次，程序在任何情况下都不会崩溃。<br>在此基础上，程序运行时间更短，占用内存更少，就认为这个算法更好。</p>
<p>用专业一点的话总结，就是如下几点：</p>
<ul>
<li>准确性：彻底解决问题</li>
<li>健壮性：不崩溃</li>
<li>时间复杂度：时间效率</li>
<li>空间复杂度：占用空间</li>
</ul>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>判断一个算法的运行时间，不会真的把它编写出来，然后运行一遍，看他的时间消耗。而是通过一个合理的方法预估它的运行时间。  </p>
<p>那么如何预估？<br>计算每条语句的执行次数（又叫该语句的频度）。用总的执行次数间接表示程序运行时间。  </p>
<p>频度可以简化：  </p>
<ul>
<li>加法常数，去掉</li>
<li>无限大变量，只保留指数最高的变量式子</li>
<li>最高项系数简化为1</li>
</ul>
<p>使用大O记法（是字母O，不是数字0）来表示算法的运行时间。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(频度)</span><br></pre></td></tr></table></figure>

<p>这里的频度是简化后的频度。<br>常见的时间复杂度:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O( n^2 )平方阶 &lt; O( n^3 )立方阶 &lt; O( 2^n )指数阶</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>通常，影响算法空间复杂度最大的是运行时申请的临时存储空间。和时间复杂度类似，算法的空间复杂度也用大O记法表示。  </p>
<p>如果程序所占用的空间，不随某个变量n的大小变化，也就是他的存储空间是固定的，那么这个算法的空间复杂度为O(1)。<br>如果随着n增大，程序申请的空间成线性增长，则空间复杂度为O(n)。<br>同理，成平方关系增长，就是O( n^2 )；成立方关系增长，就是O(n^3)。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/09/05/%E6%A0%88/</url>
    <content><![CDATA[<h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><p>栈和顺序表、链表一样，也是存储逻辑关系为“一对一”的数据。<br>和顺序表、链表不一样的是，栈的存和取有限制：</p>
<ul>
<li>一端封闭，一端开口，只能从开口处存取数据</li>
<li>存取遵循“先进后出”的原则，即最先进栈的元素最后出栈</li>
</ul>
<p>因此，栈是只能从一端存取数据的先进后出的数据结构。<br>开口的一端叫栈顶，封闭的一端叫栈底。向栈中添加数据叫进栈，从栈中取数据叫出栈。</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>栈主要有两种实现方式：</p>
<ul>
<li>顺序栈：采用顺序存储结构</li>
<li>链栈：采用链式存储结构</li>
</ul>
<h3 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h3><p>因为栈有不同的实现，所以定义一个接口，可以根据接口实现不同的栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IStack&lt;T&gt;</span><br><span class="line">&#123; </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 栈内元素数量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    int Count &#123; get; &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 栈是否为空</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    bool IsEmpty &#123; get; &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 向栈中添加数据</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">    void Push(T elem);</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 从栈顶取出数据</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    T Pop();</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 查询栈顶数据，不取出</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    T Peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>顺序栈采用动态顺序表实现。<br>我们知道，从动态顺序表的末尾添加和移除元素是最快的，为<code>O(1)</code>。因此，入栈操作就是向顺序表末尾添加元素，出栈操作就是从顺序表末尾移除元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">public class SeqStack&lt;T&gt;: IStack&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private DynamicSeqList&lt;T&gt; list;</span><br><span class="line">    public int Count &#123; get &#123; return list.Count; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsEmpty &#123; get &#123; return list.Count &lt;= 0; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public SeqStack(int capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        list = new DynamicSeqList&lt;T&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SeqStack()</span><br><span class="line">    &#123;</span><br><span class="line">        list = new DynamicSeqList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Push(T elem)</span><br><span class="line">    &#123;</span><br><span class="line">        list.Add(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        return list.RemoveAt(list.Count - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T Peek()</span><br><span class="line">    &#123;</span><br><span class="line">        return list[list.Count - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.Append(&quot;[&quot;);</span><br><span class="line">        for (int i = 0; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(list[i].ToString());</span><br><span class="line">            if (i &lt; list.Count - 1)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.Append(&quot;]Top&quot;);</span><br><span class="line">        return sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>链栈采用单链表实现。<br>我们知道，从单链表的表头添加和移除元素是最快的，为<code>O(1)</code>。因此，入栈操作就是从表头添加元素，出栈操作就是从表头移除元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">public class LinkStack&lt;T&gt; : IStack&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private SingleLinkList&lt;T&gt; list;</span><br><span class="line">    public int Count &#123; get &#123; return list.Count; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public bool IsEmpty &#123; get &#123; return list.Count &lt;= 0; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    public LinkStack()</span><br><span class="line">    &#123;</span><br><span class="line">        list = new SingleLinkList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Push(T elem)</span><br><span class="line">    &#123;</span><br><span class="line">        list.AddFirst(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        return list.RemoveFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T Peek()</span><br><span class="line">    &#123;</span><br><span class="line">        return list.GetFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        sb.Append(&quot;Top:&quot;);</span><br><span class="line">        for (int i = 0; i &lt; list.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var elem = list.Get(i);</span><br><span class="line">            sb.Append(elem.ToString());</span><br><span class="line">            sb.Append(&quot;-&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.Append(&quot;Null&quot;);</span><br><span class="line">        return sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/08/27/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><p>链表又叫单链表，是链式存储结构的线性表。在内存中是散乱随机存储的。<br>链表中的数据由结点表示，由两部分组成：</p>
<ul>
<li>数据本身，所在区域称为数据域</li>
<li>指向直接后继元素的指针（C#中为引用），所在区域称为指针域</li>
</ul>
<h2 id="头指针、头结点、首元结点是什么？"><a href="#头指针、头结点、首元结点是什么？" class="headerlink" title="头指针、头结点、首元结点是什么？"></a>头指针、头结点、首元结点是什么？</h2><p>一个链表光有结点还不完整。<br>一个完整的链表由以下几部分构成：</p>
<ul>
<li>头指针：永远指向链表第一个位置。用于指明链表的位置，便于找到链表并使用链表中的数据。</li>
<li>结点：<ul>
<li>头结点：没有数据的空结点，作为链表的第一个结点。不是必须有。</li>
<li>首元结点：链表中第一个存有数据的结点。</li>
<li>其他结点：链表中除以上结点以外的其他的结点。</li>
</ul>
</li>
</ul>
<p>链表中有头结点时，头指针指向头结点。没有头结点时，头指针指向首元结点。  </p>
<h2 id="链表及其变种"><a href="#链表及其变种" class="headerlink" title="链表及其变种"></a>链表及其变种</h2><ul>
<li>按照结点方向：单链表、双向链表</li>
<li>按照是否循环：普通链表、循环链表</li>
<li>按照是否带头结点：有头结点的、没有头结点的</li>
<li>按照头结点位置：头结点在链表首、头结点在链表尾</li>
</ul>
<h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><p>这里以无头结点普通单链表为例。<br>普通单遍历链表有一个限制：只通过头指针开始遍历</p>
<h3 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h3><p>首先实现链表的结点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Node&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public T Elem;</span><br><span class="line">    public Node&lt;T&gt; Next;</span><br><span class="line"></span><br><span class="line">    public Node()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(T elem)</span><br><span class="line">    &#123;</span><br><span class="line">        Elem = elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(T elem, Node&lt;T&gt; next)</span><br><span class="line">    &#123;</span><br><span class="line">        Elem = elem;</span><br><span class="line">        Next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return Elem.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>链表的初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Node&lt;T&gt; Head;</span><br><span class="line">private int count;</span><br><span class="line"></span><br><span class="line">public int Count &#123; get &#123; return count; &#125; &#125;</span><br><span class="line">public bool IsEmpty &#123; get &#123; return count &lt;= 0; &#125; &#125;</span><br><span class="line"></span><br><span class="line">public SingleLinkList()</span><br><span class="line">&#123;</span><br><span class="line">    Head = null;</span><br><span class="line">    count = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 插入</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Insert(int index, T elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; count)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentException(&quot;非法索引&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Head = new Node&lt;T&gt;(elem, Head);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; tmp = Head;</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp.Next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.Next = new Node&lt;T&gt;(elem, tmp.Next);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 从头部插入</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void AddFirst(T elem)</span><br><span class="line">&#123;</span><br><span class="line">    Insert(0, elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 从尾部插入</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void AddLast(T elem)</span><br><span class="line">&#123;</span><br><span class="line">    Insert(count, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据索引号移除</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T RemoveAt(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt;= count)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; node = Head;</span><br><span class="line">        Head = Head.Next;</span><br><span class="line">        count--;</span><br><span class="line">        return node.Elem;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; tmp = Head;</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp.Next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; node = tmp.Next;</span><br><span class="line">        tmp.Next = node.Next;</span><br><span class="line">        count--;</span><br><span class="line">        return node.Elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据索引号从头部移除</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T RemoveFirst()</span><br><span class="line">&#123;</span><br><span class="line">    return RemoveAt(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据索引号从尾部移除</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T RemoveLast()</span><br><span class="line">&#123;</span><br><span class="line">    return RemoveAt(count - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 移除元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Remove(T elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (Head == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Head.Elem.Equals(elem))</span><br><span class="line">    &#123;</span><br><span class="line">        Head = Head.Next;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; cur = Head;</span><br><span class="line">        Node&lt;T&gt; pre = null;</span><br><span class="line">        while (cur != null)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cur.Elem.Equals(elem))</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.Next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cur != null)</span><br><span class="line">        &#123;</span><br><span class="line">            pre.Next = cur.Next;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 根据索引号设置元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">public void Set(int index, T elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt;= count)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; tmp = Head;</span><br><span class="line">    for (int i = 0; i &lt; index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp.Next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.Elem = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 获取链表中的元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T Get(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt;= count)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt; tmp = Head;</span><br><span class="line">    for (int i = 0; i &lt; index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp.Next;</span><br><span class="line">    &#125;</span><br><span class="line">    return tmp.Elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 获取第一个元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T GetFirst()</span><br><span class="line">&#123;</span><br><span class="line">    return Get(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 获取最后一个元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public T GetLast()</span><br><span class="line">&#123;</span><br><span class="line">    return Get(count - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 是否包含某个元素</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;elem&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public bool Contains(T elem)</span><br><span class="line">&#123;</span><br><span class="line">    for (Node&lt;T&gt; node = Head; node != null; node = node.Next)</span><br><span class="line">    &#123;</span><br><span class="line">        if (node.Elem.Equals(elem))</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>链表的反转，有4中实现方式：</p>
<ul>
<li>迭代反转法</li>
<li>递归反转法</li>
<li>就地逆置法</li>
<li>头插法</li>
</ul>
<p>这里使用迭代法实现了一遍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 链表反转，迭代反转法</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public void Reverse()</span><br><span class="line">&#123;</span><br><span class="line">    if (Head == null || Head.Next == null)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt; begin = null;</span><br><span class="line">    Node&lt;T&gt; mid = Head;</span><br><span class="line">    Node&lt;T&gt; end = mid.Next;</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        mid.Next = begin;</span><br><span class="line"></span><br><span class="line">        if (end == null)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        begin = mid;</span><br><span class="line">        mid = end;</span><br><span class="line">        end = end.Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Head = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表</title>
    <url>/2021/08/18/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="什么是顺序表？"><a href="#什么是顺序表？" class="headerlink" title="什么是顺序表？"></a>什么是顺序表？</h2><p>线性表是逻辑关系为1对1的数据结构。数据结构分为顺序存储结构和链式存储结构。<br>顺序表就是顺序存储结构的线性表。<br>顺序表又分为静态顺序表和动态顺序表：</p>
<ul>
<li>静态顺序表：列表最大长度固定，不会在运行时改变。</li>
<li>动态顺序表：运行时可以根据数据的多少，动态改变列表的最大长度。</li>
</ul>
<h2 id="静态顺序表的实现"><a href="#静态顺序表的实现" class="headerlink" title="静态顺序表的实现"></a>静态顺序表的实现</h2><p>通过数组实现。具体数据结构为:<br>数组和表的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public StaticSeqList</span><br><span class="line">&#123;</span><br><span class="line">    private int[] list;</span><br><span class="line">    private int count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以定义一些方便使用的属性和方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Count &#123; get &#123; return count; &#125; &#125;</span><br><span class="line">public bool IsEmpty &#123; get &#123; return count &lt;= 0; &#125; &#125;</span><br><span class="line">public bool IsFull &#123; get &#123; return count &gt;= list.Length; &#125; &#125;</span><br><span class="line"></span><br><span class="line">//索引号是否超出范围</span><br><span class="line">private bool IsOutOfRange(int index)</span><br><span class="line">&#123;</span><br><span class="line">    return (index &lt; 0 || index &gt;= count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化就是给数组分配一个固定长度的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public StaticSeqList(int capacity)</span><br><span class="line">&#123;</span><br><span class="line">    count = 0;</span><br><span class="line">    list = new int[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现的操作"><a href="#实现的操作" class="headerlink" title="实现的操作"></a>实现的操作</h3><p>顺序表的操作主要就是增、删、改、查。</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>添加分为：</p>
<ul>
<li>添加到末尾</li>
<li>插入到某个位置  </li>
</ul>
<h5 id="添加到末尾"><a href="#添加到末尾" class="headerlink" title="添加到末尾"></a>添加到末尾</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void Add(int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new OutOfMemoryException();</span><br><span class="line">    &#125;</span><br><span class="line">    list[count++] = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入到某个位置"><a href="#插入到某个位置" class="headerlink" title="插入到某个位置"></a>插入到某个位置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void Insert(int index, int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; count)</span><br><span class="line">    &#123;</span><br><span class="line">        //可在末尾插入</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (IsFull)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new OutOfMemoryException();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = count - 1; i &gt;= index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i + 1] = list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    list[index] = elem;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>移除分为：</p>
<ul>
<li>根据索引号移除</li>
<li>根据元素移除</li>
</ul>
<h5 id="根据索引号移除"><a href="#根据索引号移除" class="headerlink" title="根据索引号移除"></a>根据索引号移除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int RemoveAt(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsOutOfRange(index))</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (IsEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new Exception(&quot;List is empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int elem = list[index];</span><br><span class="line">    for (int i = index; i &lt; count - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i] = list[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    return elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="根据元素移除"><a href="#根据元素移除" class="headerlink" title="根据元素移除"></a>根据元素移除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int Remove(int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new Exception(&quot;List is empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int removeIndex = -1;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (list[i] == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            removeIndex = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (removeIndex != -1)</span><br><span class="line">    &#123; </span><br><span class="line">        RemoveAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return removeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Set(int index, int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsOutOfRange(index))</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    list[index] = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找分为：</p>
<ul>
<li>根据索引号查找元素</li>
<li>根据元素查找索引号</li>
</ul>
<h5 id="根据索引号查找元素"><a href="#根据索引号查找元素" class="headerlink" title="根据索引号查找元素"></a>根据索引号查找元素</h5><p>使用this</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int Get(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsOutOfRange(index))</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    return list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="根据元素查找索引号"><a href="#根据元素查找索引号" class="headerlink" title="根据元素查找索引号"></a>根据元素查找索引号</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int IndexOf(int elem)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (list[i] == elem)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用索引器"><a href="#使用索引器" class="headerlink" title="使用索引器"></a>使用索引器</h5><p>给元素赋值和根据索引号查找元素可以使用索引器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int this[int index]</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return Get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    set</span><br><span class="line">    &#123;</span><br><span class="line">        Set(index, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态顺序表的实现"><a href="#动态顺序表的实现" class="headerlink" title="动态顺序表的实现"></a>动态顺序表的实现</h2><p>动态顺序表和静态顺序表的基本一致，差别是动态顺序表的增操作做了扩展数组的操作，删操作做了缩减数组的操作，并且初始化有一些细微的变化。  </p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>为了方便扩展和缩减数组，初始化时，可以指定一个扩展和缩减的长度，叫做segment。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DynamicSeqList(int segment = 4)</span><br><span class="line">&#123;</span><br><span class="line">    segmentLength = segment;</span><br><span class="line">    count = 0;</span><br><span class="line">    list = new int[segmentLength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态扩展"><a href="#动态扩展" class="headerlink" title="动态扩展"></a>动态扩展</h4><p>当表的长度已经达到数组最大长度时，此事再添加元素，自动将数组增加segment长度。<br>C#中更改数组大小的方式是将数组重新分配一个空间，并将原数组的数据赋给新的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void ExpandList()</span><br><span class="line">&#123;</span><br><span class="line">    int newLength = list.Length + segmentLength;</span><br><span class="line">    int[] tmp = list;</span><br><span class="line">    list = new int[newLength];</span><br><span class="line">    for (int i = 0; i &lt; tmp.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Add(int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsFull)</span><br><span class="line">    &#123;</span><br><span class="line">        ExpandList();</span><br><span class="line">    &#125;</span><br><span class="line">    list[count++] = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Insert(int index, int elem)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; count)</span><br><span class="line">    &#123;</span><br><span class="line">        //可在末尾插入</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (IsFull)</span><br><span class="line">    &#123;</span><br><span class="line">        ExpandList();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = count - 1; i &gt;= index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i + 1] = list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    list[index] = elem;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态缩减"><a href="#动态缩减" class="headerlink" title="动态缩减"></a>动态缩减</h4><p>当表的长度很小时，空闲的空间不小于1个segment长度时，空间就比较浪费了，此时就需要缩减数组空间。<br>但是如果当空闲长度刚好不小于1个segment时就缩减数组空间，之后再增加空间，就会重新分配空间。在这个临界值附近频繁发生增删数据的话，就会频繁申请内存，效率低下。所以，我们会在刚好达到这个临界值时再移除一次才会缩减数组空间，来减少上述情况的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void CutDownList()</span><br><span class="line">&#123;</span><br><span class="line">    int newLength = list.Length - segmentLength;</span><br><span class="line">    int[] tmp = list;</span><br><span class="line">    list = new int[newLength];</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int RemoveAt(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (IsOutOfRange(index))</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IndexOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    if (IsEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new Exception(&quot;List is empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int elem = list[index];</span><br><span class="line">    for (int i = index; i &lt; count - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i] = list[i + 1];</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    if (count &lt; list.Length - segmentLength)</span><br><span class="line">    &#123;</span><br><span class="line">        //为什么不是count &lt;= list.Length - segmentLength?</span><br><span class="line">        //让元素数量比list.Length - segmentLength再小一位，当下次增加元素时，不会立即扩展而申请内存</span><br><span class="line">        //可以防止在此临界值的时候频繁申请内存</span><br><span class="line">        CutDownList();</span><br><span class="line">    &#125;</span><br><span class="line">    return elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
